{"pages":[],"posts":[{"title":"","text":"这里记录一下之前在虚拟机上进行实验的操作指令： vi 编辑文本 i 插入 esc 切换至命令行模式 ：wq 保存并退出 ：q！ 不保存强制退出 linux文件前缀表示含义： d -文件夹 ‘-‘ 文件 r 可读 w 可写 x 可执行 tar -zxvf 解压 tar tar -zxvf xxx -C app gz tar.gz / tgz bz2 [tar.bz2]( 感觉平时不用的话很容易忘记啊…","link":"/2020/03/23/Linux常用指令学习/"},{"title":"Java虚拟机学习","text":"1.简述jvm的内存布局jvm的内存布局分为5块：程序计数器，虚拟机栈，本地方法栈。堆，方法区。程序计数器：可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，比如，分支、循环、跳转、异常处理，线程恢复等基本功能都要依赖于这个计数器来完成。 线程私有，它的生命周期与线程相同。可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，如：分支、循环、跳转、异常处理、线程恢复（多线程切换）等基础功能。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（undefined）。程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，所以此区域不会出现OutOfMemoryError的情况。 虚拟机栈：描述的的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到结束的过程就代表着栈帧从入栈到出栈的过程。 线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 本地方法栈： 与虚拟机栈非常相似，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 堆：Java虚拟机中管理的最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 被所有线程共享，在虚拟机启动时创建，用来存放对象实例，几乎所有的对象实例都在这里分配内存。对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；新生代又有Eden空间、From Survivor空间、To Survivor空间三部分。 Java 堆不需要连续内存，并且可以通过动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现，HotSpot 虚拟机把它当成永久代（Permanent Generation）来进行垃圾回收。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 运行时常量： 运行时常量池是方法区的一部分。Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。注：在 JDK1.7之前，HotSpot 使用永久代实现方法区；HotSpot 使用 GC 分代实现方法区带来了很大便利；从 JDK1.7 开始HotSpot 开始移除永久代。其中符号引用（Symbols）被移动到 Native Heap中，字符串常量和类引用被移动到 Java Heap中。在 JDK1.8 中，永久代已完全被元空间(Meatspace)所取代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 直接内存： 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。在 JDK 1.4 中新加入了 NIO 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和 Native 堆中来回复制数据。 2.简单叙述你所知道的垃圾回收算法与垃圾回收器标志-清除算法 复制算法 标志-整理算法 分代收集算法 垃圾回收器： 3.在垃圾回收对象的时候程序的逻辑是否可以继续执行不同的垃圾收集器不同。Serial、ParNew 等会 Stop-The-World。而 CMS 和 G1 等会在某一阶段停顿用户线程 (CMS 是在初始标记和重新标记。而 G1 是在初始标记阶段会停顿用户线程，最终标记也需要停顿线程，但是可以并行执行；筛选回收也能做到与用户线程一起并发执行，时间是用户可控的，但是停顿用户线程能够大大提高收集效率) 4.将对象从年轻代到老年代是如何判断该对象的执行了多久？以及什么情况下发送转移？哪些对象在老年代中？（1）是这样的，年轻代的话分为eden区和surviver from,survivor to三个区。一般来说，新生成的对象是存在在eden区，然后当eden区被塞满的时候，所有经过垃圾回收还存活的对象就会转入surviver from区，如果from也满了的话，那么from区的数据就会进入到to区，eden区的数据会被直接塞到to区，当to区也被填满的时候，如果之前存活的对象还在活动，那么就会直接进入老年区。而且就是说两个survivor区总有一个是空的。 （2）就是说我们有一个年龄计数器，那么每经过一次GC仍然存活的对象的年龄就会+1，那么如果年龄超过了一个我们限定的值，那么这个对象就会进入老年代。 还有另一种形式，就是动态判定。就是说在survivor区中如果年龄相同的多个对象超过了survivor区中的一半，那么年龄大于等于这个年龄数的这些对象就直接进入老年区。 （3）a.内存连续的大对象 b.长期存活的对象进入老年代 （4）我们在进行minorGC的时候，首先虚拟机会进行一个判断，就是判断老年代最大可用的连续空间 &gt;年轻代的总对象空间，如果满足，则执行。 ​ 如果不满足，且担保失败设置为 True ，继续判断老年代最大可用的连续空间 &gt; 历次晋升老年代对象的平均大小，如果大于的话，则冒险进行一次minorGC，如果小于的话，那么就得进行FULL GC。 –Minor GC 发生年轻代，频率高速度也快。 –MajorGC 是清理老年代 –FullGC 是清理整个堆空间–年轻代和老年代。 5.简单叙述minor与fullgc。从年轻代空间回收内存称为minorGC。 fullGC收集整个堆，包括年轻代空间以及老年代空间以及元数据等所有部分。速度比较慢。一般认为完成一次fullGC的时间是minorGC时间的10倍以上。 6.java虚拟机new一个对象创建的过程。类的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。 7.简述虚拟机栈中各个部分栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构。他是虚拟机运行时数据区中的虚拟机栈的栈元素。 栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。 9.简述java内存模型的happen before 原则简要的说就是，如果A线程满足happen-before B线程，那么A线程对变量的操作，都能被B线程观察到。 （1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 （2）两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。 10.jvm outmemory的种类堆溢出 栈溢出 永久区溢出 11.方法区会发生OutOfMemoryError吗？什么时候会呢？发生之后你怎么解决？会发生。在加载很多的Class时，就很有可能出现永久带的错误（内存溢出）。 通过设置JVM启动参数来解决，-xx:MaxPermSize=256m 12.一个程序在内存中都有哪些数据，哪些会占实际的内存。emm。。 13.jvm如何判断对象是否失效，可达性分析是否可以解决循环引用。引用计数器，但是没办法解决互相引用的问题。 可达性分析，可以。 强引用：除非对象引用被释放，才可以被回收。 软引用：只有当内存不足时，对象才会被回收。 弱引用：在第一次经历GC，无论内存足不足，都会被回收。 虚引用：因为虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时， 如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。所以程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。 如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 14.说出你所知道的jvm垃圾回收算法。CMS收集器。G1收集器。 15.java的方法区中中存放哪些东西？JVM如何控制方法区的大小以及内存溢出的原因和解决。方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。“PermGen space”是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGenspace”。但是用永久代实现方法区，并不是一个好主意，因为这样容易遇到内存溢出问题。 垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区就永久存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。 在 Java8 中，永久代被删除，方法区的 HotSpot 的实现为 Metaspace 元数据区，不放在虚拟机中而放在本地内存中，存储类的元信息；而将类的静态变量（放在 Class 对象中）和运行时常量池放在堆中","link":"/2019/08/29/JVM相关知识总结/"},{"title":"SpringMVC执行流程","text":"SpringMVC控制流程1.浏览器url–&gt;web容器–&gt;DispatchServlet2.DispatchServlet接收到请求后调用HandleMapping处理器映射器3.HandleMapping根据请求的url找到具体的处理器，生成处理器对象及处理器拦截器，然后一并返回给DispatchServlet4.DispatchServlet通过HandleAdapter处理器适配器调用处理器5.执行Controller6.Controller执行完后返回ModelAndView7.HandleAdapter将Controller返回的ModelAndView返回给DispatchServlet8.Dispatch将ModelAndView传给ViewReslover视图解析器9.ViewReslover解析完毕后返回具体的View10.DispatchServlet对View进行渲染视图（将模型数据填充至视图中）11.DispatchServlet响应用户","link":"/2019/08/27/SpringMVC执行流程/"},{"title":"love and company","text":"《我曾七次鄙视我的灵魂》 ——纪伯伦 第一次，当它本可进取时，却故作谦卑；第二次，当它在空虚时，用爱欲来填充；第三次，在困难和容易之间，它选择了容易；第四次，它犯了错，却借由别人也会犯错来宽慰自己；第五次，它自由软弱，却把它认为是生命的坚韧；第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副；第七次，它侧身于生活的污泥中，虽不甘心，却又畏首畏尾。","link":"/2019/08/31/hey,csy/"},{"title":"zookeeper学习","text":"zookeeper的学习应该来说是很有趣的，因为从开始了解分布式，然后慢慢的一层层揭开的感觉还是很美好的。 so,什么是zookeeper？ Zookeeper 主要就是文件系统+监听机制，由两个特性进行管理。","link":"/2019/08/26/zookeeper学习/"},{"title":"dubbo学习","text":"1.解压zookeeper3.5.5 2.现在一台节点上配置 ​ 进入conf目录 ​ 配置zoo.cfg文件 ​ 修改dataDir ​ 后面追加 server.1=itcast05:2888:3888 server.2=itcast06:2888:3888 server.3=itcast07:2888:3888","link":"/2019/08/27/zookeeper集群配置/"},{"title":"二叉树遍历","text":"1.创建节点12345678910//节点 static class Node{ public int var; public Node left; public Node right; public Node(int var){ this.var = var; } } 2.创建树123456789101112//创建树 static Node createTree(int[] arr,int i){ if(i&gt;=arr.length || arr[i]==-1){ return null; } Node root = new Node(arr[i]); root.left = createTree(arr,2*i+1); root.right = createTree(arr,2*i+2); return root; } 3.前序遍历1234567891011121314151617181920212223242526272829//树的前序遍历 static void preOrder(Node T){ if (T == null){ return; } System.out.print(T.var+&quot; &quot;); preOrder(T.left); preOrder(T.right); } //树的非递归前序遍历 static void iterativePre(Node root){ if (root == null){ return; } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node p = root; while (!stack.empty() || p != null){ if (p != null){ stack.push(p); System.out.print(p.var+&quot; &quot;); p = p.left; }else { p = stack.pop(); p = p.right; } } } 4.中序遍历1234567891011121314151617181920212223242526272829//树的中序遍历 static void inOrder(Node T){ if (T == null){ return; } inOrder(T.left); System.out.print(T.var+&quot; &quot;); inOrder(T.right); } //树的非递归中序遍历 static void iterativeIn(Node root){ if (root == null){ return; } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node p = root; while (!stack.empty() || p != null){ if (p != null){ stack.push(p); p = p.left; }else { p = stack.pop(); System.out.print(p.var+&quot; &quot;); p = p.right; } } } 5.后序遍历12345678910111213141516171819202122232425262728//树的后序遍历static void afterOrder(Node T){ if (T == null){ return; } afterOrder(T.left); afterOrder(T.right); System.out.print(T.var+&quot; &quot;);}//树的非递归后序遍历static void iterativeAfter(Node root){ if (root == null){ return; } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Stack&lt;Node&gt; stack2 = new Stack&lt;&gt;(); Node p = root; stack.push(p); while (!stack.empty()){ p = stack.pop(); stack2.push(p); if (p.left != null) stack.push(p.left); if (p.right != null) stack.push(p.right); } while (!stack2.empty()){ System.out.print(stack2.pop().var+&quot; &quot;); }} 6.层次遍历12 7.测试12345678910111213141516171819202122public static void main(String args[]){ int[] test = {1,2,3,4,5,6,7,8,-1,9,-1,10,-1,11,-1}; System.out.println(&quot;-----树的前序遍历&quot;); preOrder(createTree(test,0)); System.out.println(); System.out.println(&quot;-----树的中序遍历&quot;); inOrder(createTree(test,0)); System.out.println(); System.out.println(&quot;-----树的后序遍历&quot;); afterOrder(createTree(test,0)); System.out.println(); System.out.println(&quot;-----树的非递归前序遍历&quot;); iterativePre(createTree(test,0)); System.out.println(); System.out.println(&quot;-----树的非递归中序遍历&quot;); iterativeIn(createTree(test,0)); System.out.println(); System.out.println(&quot;-----树的非递归后序遍历&quot;); iterativeAfter(createTree(test,0)); System.out.println();}","link":"/2019/08/15/二叉树遍历/"},{"title":"dubbo学习","text":"什么是dubbo？一个RPC框架。 什么是RPC框架？RPC：远程过程调用协议。 实现原理我们有服务提供方和服务消费方。造个场景，比如说在分布式系统的架构中，那么服务A想用服务B中的一个功能，这个时候服务A和B是部署在不同的服务器上的，那么怎么调用呢？首先我们先序列化请求对象A，然后进行一个请求通信对象，怎么进行请求通信对象呢？我们会进行一个协议编码，然后通过流的方式传输给服务器B，服务器B再进行一个协议解码获得通信请求对象，然后再反序列化，反序列化后，进行一个反射调用进行业务操作，响应我们的请求对象，最后再通过序列化和协议编码的方式传输回服务消费方。 调用过程1.建立通信 A要调用B，首先要建立TCP连接，远程过程调用所有的交换数据都是在这个连接里传输。连接可以是按需连接（调用结束就断掉），也可以是长连接，多个远程过程调用共享同一个连接。 2.服务寻址 意思就是说，A服务器上的应用怎么告诉底层RPC框架，如何连接到B服务器上特定的端口以及方法名称是什么。一般来说，我们需要提供B服务器上方法的名称以及调用的参数等信息，才能完成一次完整的服务调用。 比较靠谱的的寻址方式，比如用redis或者zookeeper来注册服务等等。 3.网络传输 3.1 序列化 当A机器上的一个应用发起一个RPC调用时，调用方法和入参信息需要通过底层的网络协议比如TCP传输到B机器，由于网络协议是基于二进制的，所以我们需要将传输的数据先进行序列化才能在网络中进行传输。 3.2 反序列化 当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作，即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用,通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。 4.服务调用 B机器进行本地调用（通过代理Proxy和反射调用）之后得到了返回值，此时还得将返回值发送会A机器。所以还要将返回值进行序列化，寻址服务，网络传输再发送回A服务器上。A服务器再进行一个相应的操作，这样一个完成的RPC调用才算完成。 RPC架构组件一般包含四部分： 客户端：服务调用方。 客户端存根：存放服务端地址信息，将客户端的请求参数数据打包成网络消息，再通过网络传输发送给服务端。 服务端：服务提供方。 服务端存根：接收客户端发送过来的请求消息并进行解包，然后调用本地服务进行处理。 ——————————-1、服务消费者（client客户端）通过本地调用的方式调用服务； 2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体； 3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端； 4、服务端存根（server stub）收到消息后进行解码（反序列化操作）； 5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理； 6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）； 7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方； 8、客户端存根（client stub）接收到消息，并进行解码（反序列化）； 9、服务消费方得到最终结果； —-待补—-","link":"/2019/09/30/dubbo学习小结/"},{"title":"初识分布式","text":"为什么我们需要分布式架构？随着应用规模的迅速扩张，单台机器的部署已经难以支撑用户大规模、高并发的请求了， 因此服务化、集群化、分布式概念应运而生。 分布式系统常见的问题总结起来，分布式系统中最常出现的问题是：通信异常，表现为网络通信成功，失败和超时；节点故障，包括宕机和OOM。 以上所讲的问题之所以会出现是因为我们的服务是部署在不同的服务器上的。那么我们应该怎样设计才能符合一个比较好的分布式系统架构呢？先来看下什么是CAP理论。 CAP理论指的是在一个分布式系统中，同时不能满足一致性（consistency）、可用性（availability）、分区容错性（partition tolerance）这三个基本需求，最多只能满足其中的两个。下面解释一下这三个名词的意思： 一致性：指的就是数据的准确性。数据在多个副本中是否能够保存一致的特性。并在当数据在执行完更新操作后，仍然保证系统数据处于一致的状态。 可用性（高可用）：系统提供的服务必须是处于一直可用的状态。对于一个用户的请求必须在有限的时间内返回结果，这种体验感应该得跟单机模式下的请求是一样的。返回的结果应该是一个正常的响应结果，而不是out of memory这类系统错误信息。 分区容错性（数据分片）：分布式系统在遇到任何网络分区故障的时候，仍然能提供高一致性和可用性的服务，除非是整个网络系统都出现了破坏。组成分布式系统的每个节点的加入和退出都可以看成是一个特殊的网络分区。 那么我们上述说到一个分布式系统是无法同时满足一致性、可用性、分区容错性这三个特征。那么我们应该怎么做一个权衡呢？ 首先，在这三者中取两者，必须考虑的一个就是P（分区容错性），这个是不能忽略的。因为在分布式系统中，不同的服务是部署在不同的服务器上的，在子网络中，网络问题是必然出现的异常，网络通信问题是必然存在的。那么我们只能在剩下的C和A中进行权衡。我们说过了，用户的数据准确性是需要保证的，而我们的服务也是需要正常提供的。那么这就出现了一个很矛盾的问题，既要保证我们的用户体验正常又不能同时满足CAP理论，那么我们的分布式系统应该怎么来设计呢？再来看一个BASE理论。 BASE理论指的是基本可用性、软状态、最终一致性。所以BASE理论是基于CAP理论演化而来，是对CAP理论中一致性和可用性的一种权衡的结果。 核心思想：即使无法做到强一致性，但每个业务根据自身的特点，采用适当的方式来使系统达到最终一致性。 基本可用性：指的是当系统发送故障时，允许降低用户的部分功能，保持核心功能，但是不是指说不可用。比如我们在进行一个浏览器搜索时，平时可能0.5s返回结果，现在由于故障我们可能2s才返回。网页访问过大时，部分用户提供降级服务等等。 软状态：指的是系统允许存在中间状态，并且该中间状态不会影响到系统的整体可用性。即允许系统在不同节点间进行副本同步的时候存在延时。 最终一致性：系统中的所有数据副本不一定保持时刻强一致性，指的是在经过一定时间后，最终能够达到一致的状态。 BASE理论面向的是大型高可用可扩展的分布式系统，通过牺牲强一致性来获得可用性。 好了，既然采用适当的方式来使系统达到最终一致性。那么这种适当的方式是什么呢？下篇继续（2pc,3pc和及paxos）","link":"/2019/09/17/分布式理论相关知识/"},{"title":"多线程学习","text":"找了一些有关多线程的问题，因为感觉这部分知识很容易忘记，希望在看完书后可以通过回答的方式进行加深巩固。 1.为什么会出现锁机制？ Java是允许多线程并发控制的，一般在系统中，如果多个线程在操作某一共享资源变量，比如说在进行数据库的操作时，那么就有可能会引起数据脏读。那么加入锁机制就可以保证某一线程在操作时不会发生冲突，确保了数据的一致性和准确性。 2.Java线程同步的方式有哪些？ 同步的方式有同步方法，用synchronized关键字修饰的方法。同步代码块，用synchronized关键字修饰的代码块。使用特殊性变量（volatile）实现线程同步。使用Lock（一般指reentranLock）实现线程同步。提供线程内的局部变量实现线程同步，也就是用ThreadLoacl管理变量，ThreadLocal是通过为每个线程使用的该变量提供一个变量副本，副本之间是相互独立的，所以这样每个线程就可以通过操作自己的副本变量而不会影响到其他线程。==这里可以小小的总结一下，就是以上synchronized和reentranLock是通过时间换空间的方法来实现同步的，而ThreadLocal则是通过空间换时间的方式来进行同步的。 3.synchronized和volatile的区别。（1）volatile是线程同步的轻量级实现，性能比synchronized好。 （2）volatile只能修饰变量，而synchronized可以修饰方法或者代码块。 （3）volatile可以保证数据的可见性，但是不能保证原子性，而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存与公共内存中的数据做同步。 4.ThreadLocal实现原理每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，ThreadLocalMap是属于Thread的内部类，用来存放一对对的entry键值对。怎么存放，就是以当前ThreadLocal变量为键值，要保存的副本变量为vaule为一对键值对，存放到threadlocals中去。要使用时就通过get方法进行取值。应用：数据库连接。 5.java中如何创建线程？大体有4种方法。继承Thread父类，实现runnable接口，实现callable接口，线程池创建。 6.Java线程池使用有界队列实现时的饱和策略有哪些？7.启动线程时，start与run的区别是什么？start才是调用线程，直接run知识调用其中的方法。 8.介绍一下AbstaractQueuedSynchronizer？消息同步队列，可以用于构建阻塞锁或者同步容器的基础框架。 9.介绍一下ConditionCondition将Object监视器方法（wait、notify和notify）分解为截然不同的对象。变成对象后，就可以和Lock实现组合使用。Lock就代替了Synchronized方法和语句的使用，Condition就代替了Object监视方法的使用。Condition对象的实例实际上就是绑定在一个Lock锁上。 10.介绍一下Reentrantlock是一个可重入锁类。在高竞争条件下有更好的性能，且可以中断。是基于AQS实现的。 11.Java中Reentrantlock的使用场景（1）需要使用可重入锁时。 （2）并发竞争很高的情况下 （3）需要使用中可中断锁 （4）尝试等待执行。 12.Java中synchronize 与 Lock的区别（1）synchronized是使用Object本身的notify,wait,notifyAll调度机制，Lock可以使用Condition进行线程间调度。 （2）在一个对象里面可以有多个Condition,相对灵活。 （3）Lcok的上锁是通过代码实现的，而synchroniezd是通过JVM层面实现的。 13.java中synchronized代码块的实现，以及jdk1.6对锁的优化14.java中的线程池实现有哪些？FixedThreadPool底层使用的是什么任务队列？emmm.. 15.java中的线程有几种状态？什么状态是阻塞状态？新建状态（new） 就绪状态（Runnable） 运行状态（Running） 阻塞状态（Blocked） 死亡状态（Dead） 阻塞状态：等待阻塞 同步阻塞 其他阻塞 16.怎么去看一个java进程中有哪些线程处于阻塞状态的？​ jstack 17.读写锁18.CAS底层实现原理19.Java中锁的优化无锁——&gt;偏向锁——&gt;轻量级锁 ——&gt;重量级锁 20.java中thread与Runnable的区别？（1）thread属于继承，但是java类中只能单继承，所以不太好。 （2）Runnable是实现接口 21.java中闭锁CountDownLatch与栅栏CyclicBarrier的区别​ 断点 22.介绍下乐观锁和悲观锁。乐观锁：总是假设最好的情况，每次读取数据都认为别人不会读取。多读情况。 悲观锁：总是假设最坏的情况，每次拿数据都认为别人会来修改，所以会先上把锁。多写情况。 23.叙述下java中wait与sleep的区别以及notify与yied？24.介绍下java中CAS原理不使用锁的情况下实现多线程之间的变量同步。 CAS算法涉及到三个操作数 需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。","link":"/2019/08/03/多线程自我总结/"},{"title":"2PC & 3PC","text":"上篇我们说到，我们会通过适当的方法来解决最终一致性的问题。那么这个过程是怎么样的呢？首先来看下什么2PC？ 什么是3PC？","link":"/2019/09/18/到底什么是2pc&3pc？paxos算法又是什么？/"},{"title":"实习阶段总结","text":"现在来整理一下一般在项目开发中给的流程以及用到的工具。因为有点杂，就想到啥就写点啥吧。以下是我在实习期间的一点小心得。 项目原型讨论一般会有UI出稿，然后大家一起开会讨论，来说一下具体的需求。接着就是任务分配，具体分配有哪些人来完成数据库设计，前端， 后端数据接口。 数据库的设计首先是数据库的设计，一般来说，数据库的设计最好由熟悉业务的人来设计比较好，在实际工作中，我就发现，每个人对于需求的理解都是不一样的，就比如说，我们在进行“合拍”小程序开发的时候，一开始数据库是几个人一起讨论设计的，但是发现每个人在具体的数据存储方式上就有可能不同了。当然这就是一个团队沟通的具体表现了，一定要学会和你的team进行有效正确的沟通，避免出现歧义和误会。其实数据库的设计是很重要的，因为这会涉及到你后续的开发是否顺畅。比如我们一开始在进行数据库的设计的时候，就是没有考虑周全，然后被总监怼了一发，就是没有考虑扩展性，这样一来以后要是有什么新功能增加或者其他需求就不太好做操作了。所以在进行数据库的设计时一定要考虑周全。那么这个又要涉及到对业务的理解了，这就是我为什么说最好交给对业务熟悉的人来设计。 构建E-R图数据库在设计的过程中，一定要把E-R图给画清楚，表与表之间的关系，逻辑，一定要理清，这样后续在开发中才不会有很多坑。现在有很多画图软件，但是我就习惯直接在纸上用笔进行草稿，因为其实只有你自己厘清了才是最有用的…其实我觉得用笔画是最高效的。 讨论数据库设计的可行性一般设计完就会和你的team一起讨论一下咯，看看这样的设计方案是否可行，是否还有什么漏洞，还有什么需要补充的。查询性能怎么样等等。 前端开发因为在这前后端是没有具体分开做的，这就意味着还得会前端。但是我个人的话，就是停留在会用而已…（会点前端还是很重要的鸭）对于一些具体的没有太深入理解。前端是采用vue+elementUI来进行开发的。也是用vue的脚手架，elementUI用起来确实很爽，省了很多事。vue的话没有深入学习过js的话确实不太好理解。里面文件具体分工明确。关于怎么使用，后续再说。 后端开发后端的话可以springboot，很多配置文件已经帮你配好了，所以也就没有那么麻烦。数据的持久化用的的mybatis框架。关于后端，比较想总结多一点。 前后端的配合一般前后端的交互都是通过前端请求后端。所以双方的数据报文的命名一定要统一好。一般前端会通过POST，GET这两种请求方式。后端的话在接收到数据后，要进行一个数据解析，这时一般后端会设计一个DTO，也就是前端请求接口的查询条件model，然后利用@requestbody进行映射。再利用阿里的fastJSON进行处理。接着就转到业务层。业务层处理完后如果有需要进行到数据的持久化操作的话就再转到DAO层，用的是mybatis-plus。在这里的话主要就是写sql了。慢慢写才会对sql慢慢熟练。 关于model的生成一般可以利用工具进行数据库model的映射。现在这种脚本很多，也可以自己写一个。可以大大地节省你的时间。 关于异常处理以及权限拦截前后端在交互时一般都会进行一个身份认证，以及权限拦截，包括异常处理等等。这些一般都会抽象出一个框架出来。这里想说一下，权限的控制一定是要交给后端来控制的，确保接口和数据的安全性。 关于七牛云以及阿里云图片存储的使用开发调试过程中要用到内网穿透。 （后续补充吧，先这样~睡觉）","link":"/2019/09/15/实习阶段总结/"}],"tags":[{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"},{"name":"恋爱","slug":"恋爱","link":"/tags/恋爱/"},{"name":"分布式","slug":"分布式","link":"/tags/分布式/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"多线程,总结","slug":"多线程-总结","link":"/tags/多线程-总结/"},{"name":"实习","slug":"实习","link":"/tags/实习/"}],"categories":[]}