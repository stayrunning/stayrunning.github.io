{"pages":[],"posts":[{"title":"二叉树遍历","text":"1.创建节点12345678910//节点 static class Node{ public int var; public Node left; public Node right; public Node(int var){ this.var = var; } } 2.创建树123456789101112//创建树 static Node createTree(int[] arr,int i){ if(i&gt;=arr.length || arr[i]==-1){ return null; } Node root = new Node(arr[i]); root.left = createTree(arr,2*i+1); root.right = createTree(arr,2*i+2); return root; } 3.前序遍历1234567891011121314151617181920212223242526272829//树的前序遍历 static void preOrder(Node T){ if (T == null){ return; } System.out.print(T.var+&quot; &quot;); preOrder(T.left); preOrder(T.right); } //树的非递归前序遍历 static void iterativePre(Node root){ if (root == null){ return; } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node p = root; while (!stack.empty() || p != null){ if (p != null){ stack.push(p); System.out.print(p.var+&quot; &quot;); p = p.left; }else { p = stack.pop(); p = p.right; } } } 4.中序遍历1234567891011121314151617181920212223242526272829//树的中序遍历 static void inOrder(Node T){ if (T == null){ return; } inOrder(T.left); System.out.print(T.var+&quot; &quot;); inOrder(T.right); } //树的非递归中序遍历 static void iterativeIn(Node root){ if (root == null){ return; } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node p = root; while (!stack.empty() || p != null){ if (p != null){ stack.push(p); p = p.left; }else { p = stack.pop(); System.out.print(p.var+&quot; &quot;); p = p.right; } } } 5.后序遍历12345678910111213141516171819202122232425262728//树的后序遍历static void afterOrder(Node T){ if (T == null){ return; } afterOrder(T.left); afterOrder(T.right); System.out.print(T.var+&quot; &quot;);}//树的非递归后序遍历static void iterativeAfter(Node root){ if (root == null){ return; } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Stack&lt;Node&gt; stack2 = new Stack&lt;&gt;(); Node p = root; stack.push(p); while (!stack.empty()){ p = stack.pop(); stack2.push(p); if (p.left != null) stack.push(p.left); if (p.right != null) stack.push(p.right); } while (!stack2.empty()){ System.out.print(stack2.pop().var+&quot; &quot;); }} 6.层次遍历12 7.测试12345678910111213141516171819202122public static void main(String args[]){ int[] test = {1,2,3,4,5,6,7,8,-1,9,-1,10,-1,11,-1}; System.out.println(&quot;-----树的前序遍历&quot;); preOrder(createTree(test,0)); System.out.println(); System.out.println(&quot;-----树的中序遍历&quot;); inOrder(createTree(test,0)); System.out.println(); System.out.println(&quot;-----树的后序遍历&quot;); afterOrder(createTree(test,0)); System.out.println(); System.out.println(&quot;-----树的非递归前序遍历&quot;); iterativePre(createTree(test,0)); System.out.println(); System.out.println(&quot;-----树的非递归中序遍历&quot;); iterativeIn(createTree(test,0)); System.out.println(); System.out.println(&quot;-----树的非递归后序遍历&quot;); iterativeAfter(createTree(test,0)); System.out.println();}","link":"/2019/08/15/二叉树遍历/"},{"title":"love and company","text":"《我曾七次鄙视我的灵魂》 ——纪伯伦 第一次，当它本可进取时，却故作谦卑；第二次，当它在空虚时，用爱欲来填充；第三次，在困难和容易之间，它选择了容易；第四次，它犯了错，却借由别人也会犯错来宽慰自己；第五次，它自由软弱，却把它认为是生命的坚韧；第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副；第七次，它侧身于生活的污泥中，虽不甘心，却又畏首畏尾。","link":"/2019/08/31/hey,csy/"},{"title":"2019-8-14多线程学习","text":"找了一些有关多线程的问题，因为感觉这部分知识很容易忘记，希望在看完书后可以通过回答的方式进行加深巩固。 1.为什么会出现锁机制？ Java是允许多线程并发控制的，一般在系统中，如果多个线程在操作某一共享资源变量，比如说在进行数据库的操作时，那么就有可能会引起数据脏读。那么加入锁机制就可以保证某一线程在操作时不会发生冲突，确保了数据的一致性和准确性。 2.Java线程同步的方式有哪些？ 同步的方式有同步方法，用synchronized关键字修饰的方法。同步代码块，用synchronized关键字修饰的代码块。使用特殊性变量（volatile）实现线程同步。使用Lock（一般指reentranLock）实现线程同步。提供线程内的局部变量实现线程同步，也就是用ThreadLoacl管理变量，ThreadLocal是通过为每个线程使用的该变量提供一个变量副本，副本之间是相互独立的，所以这样每个线程就可以通过操作自己的副本变量而不会影响到其他线程。==这里可以小小的总结一下，就是以上synchronized和reentranLock是通过时间换空间的方法来实现同步的，而ThreadLocal则是通过空间换时间的方式来进行同步的。 #F44336== 3.synchronized和volatile的区别。（1）volatile是线程同步的轻量级实现，性能比synchronized好。 （2）volatile只能修饰变量，而synchronized可以修饰方法或者代码块。 （3）volatile可以保证数据的可见性，但是不能保证原子性，而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存与公共内存中的数据做同步。 4.ThreadLocal实现原理每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，ThreadLocalMap是属于Thread的内部类，用来存放一对对的entry键值对。怎么存放，就是以当前ThreadLocal变量为键值，要保存的副本变量为vaule为一对键值对，存放到threadlocals中去。要使用时就通过get方法进行取值。应用：数据库连接。 5.java中如何创建线程？大体有4种方法。继承Thread父类，实现runnable接口，实现callable接口，线程池创建。 6.Java线程池使用有界队列实现时的饱和策略有哪些？7.启动线程时，start与run的区别是什么？start才是调用线程，直接run知识调用其中的方法。 8.介绍一下AbstaractQueuedSynchronizer？消息同步队列，可以用于构建阻塞锁或者同步容器的基础框架。 9.介绍一下ConditionCondition将Object监视器方法（wait、notify和notify）分解为截然不同的对象。变成对象后，就可以和Lock实现组合使用。Lock就代替了Synchronized方法和语句的使用，Condition就代替了Object监视方法的使用。Condition对象的实例实际上就是绑定在一个Lock锁上。 10.介绍一下Reentrantlock是一个可重入锁类。在高竞争条件下有更好的性能，且可以中断。是基于AQS实现的。 11.Java中Reentrantlock的使用场景（1）需要使用可重入锁时。 （2）并发竞争很高的情况下 （3）需要使用中可中断锁 （4）尝试等待执行。 12.Java中synchronize 与 Lock的区别（1）synchronized是使用Object本身的notify,wait,notifyAll调度机制，Lock可以使用Condition进行线程间调度。 （2）在一个对象里面可以有多个Condition,相对灵活。 （3）Lcok的上锁是通过代码实现的，而synchroniezd是通过JVM层面实现的。 13.java中synchronized代码块的实现，以及jdk1.6对锁的优化14.java中的线程池实现有哪些？FixedThreadPool底层使用的是什么任务队列？emmm.. 15.java中的线程有几种状态？什么状态是阻塞状态？新建状态（new） 就绪状态（Runnable） 运行状态（Running） 阻塞状态（Blocked） 死亡状态（Dead） 阻塞状态：等待阻塞 同步阻塞 其他阻塞 16.怎么去看一个java进程中有哪些线程处于阻塞状态的？​ jstack 17.读写锁18.CAS底层实现原理19.Java中锁的优化无锁——&gt;偏向锁——&gt;轻量级锁 ——&gt;重量级锁 20.java中thread与Runnable的区别？（1）thread属于继承，但是java类中只能单继承，所以不太好。 （2）Runnable是实现接口 21.java中闭锁CountDownLatch与栅栏CyclicBarrier的区别​ 断点 22.介绍下乐观锁和悲观锁。乐观锁：总是假设最好的情况，每次读取数据都认为别人不会读取。多读情况。 悲观锁：总是假设最坏的情况，每次拿数据都认为别人会来修改，所以会先上把锁。多写情况。 23.叙述下java中wait与sleep的区别以及notify与yied？24.介绍下java中CAS原理不使用锁的情况下实现多线程之间的变量同步。 CAS算法涉及到三个操作数 需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。","link":"/2019/08/03/多线程自我总结/"},{"title":"实习阶段总结","text":"现在来整理一下一般在项目开发中给的流程以及用到的工具。因为有点杂，就想到啥就写点啥吧。以下是我在实习期间的一点小心得。 项目原型讨论一般会有UI出稿，然后大家一起开会讨论，来说一下具体的需求。接着就是任务分配，具体分配有哪些人来完成数据库设计，前端， 后端数据接口。 数据库的设计首先是数据库的设计，一般来说，数据库的设计最好由熟悉业务的人来设计比较好，在实际工作中，我就发现，每个人对于需求的理解都是不一样的，就比如说，我们在进行“合拍”小程序开发的时候，一开始数据库是几个人一起讨论设计的，但是发现每个人在具体的数据存储方式上就有可能不同了。当然这就是一个团队沟通的具体表现了，一定要学会和你的team进行有效正确的沟通，避免出现歧义和误会。其实数据库的设计是很重要的，因为这会涉及到你后续的开发是否顺畅。比如我们一开始在进行数据库的设计的时候，就是没有考虑周全，然后被总监怼了一发，就是没有考虑扩展性，这样一来以后要是有什么新功能增加或者其他需求就不太好做操作了。所以在进行数据库的设计时一定要考虑周全。那么这个又要涉及到对业务的理解了，这就是我为什么说最好交给对业务熟悉的人来设计。 构建E-R图数据库在设计的过程中，一定要把E-R图给画清楚，表与表之间的关系，逻辑，一定要理清，这样后续在开发中才不会有很多坑。现在有很多画图软件，但是我就习惯直接在纸上用笔进行草稿，因为其实只有你自己厘清了才是最有用的…其实我觉得用笔画是最高效的。 讨论数据库设计的可行性一般设计完就会和你的team一起讨论一下咯，看看这样的设计方案是否可行，是否还有什么漏洞，还有什么需要补充的。查询性能怎么样等等。 前端开发因为在这前后端是没有具体分开做的，这就意味着还得会前端。但是我个人的话，就是停留在会用而已…（会点前端还是很重要的鸭）对于一些具体的没有太深入理解。前端是采用vue+elementUI来进行开发的。也是用vue的脚手架，elementUI用起来确实很爽，省了很多事。vue的话没有深入学习过js的话确实不太好理解。里面文件具体分工明确。关于怎么使用，后续再说。 后端开发后端的话可以springboot，很多配置文件已经帮你配好了，所以也就没有那么麻烦。数据的持久化用的的mybatis框架。关于后端，比较想总结多一点。 前后端的配合一般前后端的交互都是通过前端请求后端。所以双方的数据报文的命名一定要统一好。一般前端会通过POST，GET这两种请求方式。后端的话在接收到数据后，要进行一个数据解析，这时一般后端会设计一个DTO，也就是前端请求接口的查询条件model，然后利用@requestbody进行映射。再利用阿里的fastJSON进行处理。接着就转到业务层。业务层处理完后如果有需要进行到数据的持久化操作的话就再转到DAO层，用的是mybatis-plus。在这里的话主要就是写sql了。慢慢写才会对sql慢慢熟练。 关于model的生成一般可以利用工具进行数据库model的映射。现在这种脚本很多，也可以自己写一个。可以大大地节省你的时间。 关于异常处理以及权限拦截前后端在交互时一般都会进行一个身份认证，以及权限拦截，包括异常处理等等。这些一般都会抽象出一个框架出来。这里想说一下，权限的控制一定是要交给后端来控制的，确保接口和数据的安全性。 关于七牛云以及阿里云图片存储的使用开发调试过程中要用到内网穿透。 （后续补充吧，先这样~睡觉）","link":"/2019/09/15/实习阶段总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"恋爱","slug":"恋爱","link":"/tags/恋爱/"},{"name":"多线程,总结","slug":"多线程-总结","link":"/tags/多线程-总结/"},{"name":"实习","slug":"实习","link":"/tags/实习/"}],"categories":[]}